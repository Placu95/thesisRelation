\chapter{Technologies}

Below the technologies and libraries used to develop the system:

\begin{itemize}
    \item \textbf{Protelis} $\rightarrow$ for the aggregate program
    \item \textbf{DingNet simulator} \footnote{\href{https://github.com/dimoibiehg/DingNet}{DingNet}} $\rightarrow$ \todo[inline, color=green!70]{added it} as simulator for LoRaWan network. DingNet simulator was chosen for two reason: it provide also a real network where is possible deploy the simulated application, and there is the possible to modify the simulator if needed.  
    \item \textbf{MQTT} $\rightarrow$ for the communication between:
    \begin{itemize}
        \item LoRaWan network and Protelis backend
        \item Protelis nodes to exchange neighborhood information
        \item Protelis nodes and Neighborhood-Manager
    \end{itemize}
    \item \textbf{Kotlin} $\rightarrow$ to implement the Protelis backend
    \item \textbf{Java v.11} $\rightarrow$ to work on the DingNet simulator that is in Java
    \item \textbf{Eclipse Paho MQTT client library}\footnote{\href{https://github.com/eclipse/paho.mqtt.java}{MQTT library}} $\rightarrow$ to implement a MQTT client for a real MQTT broker
\end{itemize}

\section{DingNet simulator}
DingNet is a simulator for a LoRaWan network of class A. It allows to:
\begin{itemize}
    \item define different types of devices
    \item configure the network parameter for each device and gateway
    \item configure the position in the environment of devices and gateways
    \item add different kind of sensors to each device 
    \item define the path that a device has to follow
    \item simulate the communication between devices and gateways in both the directions
\end{itemize}
\todo[inline, color=green!70]{added it}
DingNet provide a LoRa-over-Mqtt architecture, so all the communications from gateways to network server to applications and the opposite are based on MQTT. The network server publishes messages for application on the topic \mintinline{java}{"application/applicationID/node/nodeID/rx"}, the message contains the packet sent from the device and all the information available on the transmission. To send a message from the application to one device, the application has to publishes it on the topic \mbox{\mintinline{java}{"application/applicationID/node/nodeID/tx"}} and the message has to contain the payload of the message and the list of mac command.

How it works:
\begin{itemize}
    \item the simulator is single threaded
    \item the simulator is "time-based" with a global clock that schedules all the computations
    \item every device sends a packet every X seconds. If the packet is the same as the previous one, the packet isn't sent to avoid use of bandwidth for useless message
    \item if a device doesn't send any message for Y seconds (with Y $>$ X) then the device sends a "keepAlive" message
    \item when a gateway receives a message from a device, it publishes the message on MQTT. Then it checks if the there is a message to send to the device and if present send it.
    \item a device can receive only one message after every sended message.
    \item during a simulation step:
    \begin{itemize}
        \item device consumes packet, if it has one
        \item every movable device moves of one meter if it is pass enough time according to the movement speed
        \item at the end the global clock is increment of one tick (now 1 millisecond)
    \end{itemize}
    \item when the global clock is incremented, it checks if are present some event to fire. Now the events present are: send packet every X seconds and packet arrived to destination. In future they will be used also for:
    \begin{itemize}
        \item mote movement
        \item assure that a mote can't send more message at the same time
        \item ALOHA protocol
    \end{itemize}
\end{itemize}